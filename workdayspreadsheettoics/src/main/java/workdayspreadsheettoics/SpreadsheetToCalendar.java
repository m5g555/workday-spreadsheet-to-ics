/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package workdayspreadsheettoics;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.text.ParseException;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.Recur;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.Description;
import net.fortuna.ical4j.model.property.Location;
import net.fortuna.ical4j.model.property.RRule;
import net.fortuna.ical4j.model.property.Uid;
import net.fortuna.ical4j.util.RandomUidGenerator;
import net.fortuna.ical4j.util.UidGenerator;


public class SpreadsheetToCalendar {
  private static ArrayList<Faculty> facultyList = new ArrayList<>();
  
  public static void main(String... args) throws IOException, GeneralSecurityException, ParseException {
    // Faculty saving and loading calls
    File databaseFile = new File("faculty.txt");
    if (databaseFile.isFile()) {
      facultyList = FacultyHelperFunctions.loadFacultyFromFile(databaseFile);
    } else {
      System.out.println("");
      facultyList = FacultyHelperFunctions.loadFacultyFromURLs();
      FacultyHelperFunctions.saveFacultyListToDatabase(databaseFile, facultyList);
    }

    String fileLocation = "";
    Path currentRelativePath = Paths.get("");
    String relativePath = currentRelativePath.toAbsolutePath().toString();
    // System.out.println("Current absolute path is: " + s);
    // System.out.println(listFilesUsingFilesList(s));
    for(String str : CalendarHelperFunctions.listFilesUsingFilesList(relativePath)) {
      //System.out.println(str.substring(str.length()-5));
      if(str.substring(str.length()-5).equals(".xlsx")) {
        fileLocation = str;
        break;
      }
    }
    System.out.println(fileLocation);
    
    FileInputStream file = new FileInputStream(new File(fileLocation));
    Workbook workbook = new XSSFWorkbook(file);

    Sheet sheet = workbook.getSheetAt(0);


    // Checks if the spreadsheet is a saved schedule, and if it is passes it off to the SavedScheduleToCalendar class
    if (sheet.getRow(0).getCell(0).getStringCellValue().equals("View My Saved Schedules")){
      System.out.println("Workbook is a Saved Schedule, passing off to SavedScheduleToCalendar class");
      if (sheet.getRow(3).getCell(0).getStringCellValue().equals("Severity")) {
        SavedScheduleToCalendar.SavedScheduleToCalendar(facultyList, workbook.getSheetAt(1));
      } else {
        SavedScheduleToCalendar.SavedScheduleToCalendar(facultyList, workbook.getSheetAt(0));
      }
      return;
    }

    Map<Integer, List<String>> data = new HashMap<>();
    int i = 0;
    for (Row row : sheet) {
        data.put(i, new ArrayList<String>());
        for (Cell cell : row) {
            switch (cell.getCellType()) {
                case STRING: data.get(Integer.valueOf(i)).add(cell.getRichStringCellValue().getString()); break;
                case NUMERIC: 
                if (DateUtil.isCellDateFormatted(cell)) {
                    data.get(i).add(cell.getDateCellValue() + "");
                } else {
                    data.get(i).add(cell.getNumericCellValue() + "");
                } 
                break;
                case BOOLEAN: data.get(i).add(cell.getBooleanCellValue() + ""); break;
                case FORMULA: data.get(i).add(cell.getCellFormula() + ""); break;
                default: data.get(i).add(" ");
            }
        }
        i++;
    }
    Calendar calendar = new Calendar();
    int endRow = 0;
    int startingRow = 0;
    for (int r = 0; data.get(r).size() > 1 ? !data.get(r).get(1).equals("Course Listing") : true; r++) {
      startingRow = r+2;
    }
    System.out.println("Starting row: " + startingRow);
    for (int g = startingRow; !(data.get(g) == null) && (!data.get(g).get(0).equals("My Dropped/Withdrawn Courses") && !data.get(g).get(0).equals("Enrolled Units")); g++) {
      System.out.println("First cell in current row " + data.get(g).get(0));
      System.out.println("Breaking: " + (data.get(g+1) == null));
      List<String> row = data.get(g);
      System.out.println(g);
      System.out.println(row.get(7));
      for (int c = 0; c < row.size(); c++) {
        System.out.println((char)(65+c) + " " + c + ": " + "(" + row.get(c) + ")");
      }

      String[] temp = row.get(7).split("\n");
      System.out.println(temp.length > 1);

      if (temp.length > 1) {//Combination Classes Handler
        //System.out.println("Combination Classes");
        int sI = 0;
        for (String s : temp) {
          System.out.println(s);
          System.out.println(s.length());
          if (s.length() != 0) {
            sI++;
          }
        }
        String[] eventStrings = new String[sI];
        sI = 0;
        for (String s : temp) {
          if (s.length() != 0) {
            System.out.println(s);
            eventStrings[sI] = s;
            sI++;
          }
        }
        for (String s : eventStrings) {
          VEvent event1;
          try {
            event1 = setupAndMakeEvent(s, row.get(4), row.get(9), row.get(5), row.get(6), row.get(10), row.get(11), row.get(0));
          } catch (Exception e) {
            //This is to fix a bug
            //if the teacher is not present the program should just blank out the rows that do not exist
            event1 = setupAndMakeEvent(s, row.get(4), " ", row.get(5), row.get(6), row.get(9), row.get(10), row.get(0));
          }

          
          
          if (event1 != null) {
            calendar.add(event1);
          }
        }
        System.out.println("END");
      } else {//Every other class type
        //row.get(7) = Event Cell
        //row.get(4) = Event Name
        //row.get(9) = Instructor Cell
        //row.get(5) = Instrucational Format
        //row.get(6) = Delivery Mode Cell
        //row.get(10) = Start Cell
        //row.get(11) = End Cell
        //row.get(0) = Details

        
        VEvent event;
        try {
          event = setupAndMakeEvent(row.get(7), row.get(4), row.get(9), row.get(5), row.get(6), row.get(10), row.get(11), row.get(0));
        } catch (Exception e) {
          //This is to fix a bug
          event = setupAndMakeEvent(row.get(7), row.get(4), " ", row.get(5), row.get(6), row.get(9), row.get(10), row.get(0));
        }
        
        if (event != null) {
          calendar.add(event);
        }
      }
      endRow = g+1;
    }
    //Finding if there is a semester name and if so naming it so
    System.out.println(data.get(endRow));
    String semesterName = "";
    if (!(data.get(endRow) == null) && !data.get(endRow).get(0).equals("Enrolled Units")) {
      System.out.println("UP BY 4");
      endRow += 4;
      try {
        semesterName = data.get(endRow+2).get(1);
        System.out.println("Found Semester Name: " + semesterName);
      } catch (Exception e) {
        System.out.println("No semester name");
      }
      
    } 
    System.out.println("Getting semester name from classes");
    semesterName = semesterType;
    
    FileOutputStream fout;
    if (!semesterName.equals("")) {
      fout = new FileOutputStream(data.get(startingRow).get(0).split(" - ")[0] + " " + semesterName + ".ics");
      System.out.println("Semster Name: " + "(" + semesterName + ")");
    } else {
      fout = new FileOutputStream(data.get(startingRow).get(0).split(" - ")[0] + " " + LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy")) + ".ics");
      System.out.println("Year");
    }
    

    CalendarOutputter outputter = new CalendarOutputter();
    outputter.output(calendar, fout);

}

private static String semesterType = ""; 
private static VEvent setupAndMakeEvent(String eventInput, String eventName, String instructorCell, String instructionalFormat, String deliveryModeCell, String startCell, String endCell, String details) throws IOException {
    //row.get(7) = Event Cell
    //row.get(4) = Event Name
    //row.get(9) = Instructor Cell
    //row.get(5) = Instrucational Format
    //row.get(6) = Delivery Mode Cell
    //row.get(10) = Start Cell
    //row.get(11) = End Cell
    //row.get(0) = Details
    //                                                                  012345
    //Name - Program - Date - Inactive/Active - ClassCode - ClassName - 2024 Fall Semester
    //0    - 1       - 2    - 3               - 4         - 5         - 6

    String[] detailsArr = details.split(" - ");
    semesterType = detailsArr[6];
    //Addition For Getting Semester Type
    // if (meetingPatternsArr.length >= 6) {
    //   semesterType = meetingPatternsArr[5];//.substring(5).replaceAll(" ", "");
    // } else {
    //   System.out.println("EventDetailsNotFound");
    // }

    String[] meetingPatternsArr = eventInput.split("( \\| )|( \\|)");//Splits meeting patterns string into str componets to use later
      if (eventInput.equals(" ")) {
        System.out.println("Not scheduled take note");
        return null;
      }
      //System.out.println("Starting meeting patterns");
      for (String s : meetingPatternsArr) {
        System.out.println(s);
      }
      String[] daysMeetingStrArr = meetingPatternsArr[0].split("/");

      
      

      String location;
      
      location = (meetingPatternsArr.length < 3 ? "" : CalendarHelperFunctions.shortBuildingToAddress.containsKey(meetingPatternsArr[2].split(" ")[0]) 
                                                     ? CalendarHelperFunctions.shortBuildingToAddress.get(meetingPatternsArr[2].split(" ")[0]) 
                                                     : meetingPatternsArr[2].split(" \\d")[0]);//Defaults to short address if long address is not in hashmap
      
      Faculty instructor = null;
      if (!instructorCell.substring(0, 1).equals(" ")) {
        instructor = FacultyHelperFunctions.getFacultyFromName(facultyList, instructorCell);

      }
      String description = "Instructor - " + (instructorCell.substring(0, 1).equals(" ") ? "?" : instructorCell) + "\n" + 
                        "Instructional Format - " + instructionalFormat + "\n" + 
                        "Delivery Mode - " + deliveryModeCell + 
                        (meetingPatternsArr.length < 3 ? "" : " (" + meetingPatternsArr[2] + ")");
      System.out.println(description);
      if (instructor != null) {
        description += "\n" + "---" +
                       "\n" + "Email - " + instructor.getEmail() +
                       "\n" + "Phone - " + instructor.getPhone() +
                       "\n" + "Instructor Position - " + instructor.getStatus() +
                       "\n" + "Department - " + instructor.getDepartment() +
                       "\n" + "Office - " + instructor.getOffice() +
                       "\n" + "---";
      }

      LocalDate classesStartReccuringDate = LocalDate.parse(startCell, DateTimeFormatter.ofPattern("E MMM dd HH:mm:ss zzz yyyy"));
      LocalDate classesEndReccuringDate = LocalDate.parse(endCell, DateTimeFormatter.ofPattern("E MMM dd HH:mm:ss zzz yyyy"));

      System.out.println(classesStartReccuringDate);
      System.out.println(classesEndReccuringDate);

      LocalDate startLocalDate = CalendarHelperFunctions.getNextDateOfDayFromDate(classesStartReccuringDate, CalendarHelperFunctions.getStartDay(daysMeetingStrArr, classesStartReccuringDate));
      LocalDate endLocalDate = CalendarHelperFunctions.getNextDateOfDayFromDate(classesStartReccuringDate, CalendarHelperFunctions.getStartDay(daysMeetingStrArr, classesStartReccuringDate));
    
      String[] startAndEndTimesInHalfs = meetingPatternsArr[1].split(" - ");
      LocalTime startLocalTime = LocalTime.parse(startAndEndTimesInHalfs[0], DateTimeFormatter.ofPattern("h:mm a"));
      LocalTime endLocalTime = LocalTime.parse(startAndEndTimesInHalfs[1], DateTimeFormatter.ofPattern("h:mm a"));

      //System.out.println("Start");
      System.out.println(startLocalTime.format(DateTimeFormatter.ofPattern("h:mm a")));
      System.out.println(endLocalTime.format(DateTimeFormatter.ofPattern("h:mm a")));//2015-05-28T09:00:00-07:00

      // String startDateTimeStr = startLocalDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd")) + "T" + 
      // startLocalTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) + "-04:00";
      // System.out.println(startDateTimeStr);
      // //DateTime startDateTime = new DateTime(startDateTimeStr);


      // String endDateTimeStr = endLocalDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))  + "T" + 
      // endLocalTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) + "-04:00";
      // System.out.println(endDateTimeStr);
      // //DateTime endDateTime = new DateTime(endDateTimeStr);

      String recurrence = CalendarHelperFunctions.makeRecurrenceString(classesEndReccuringDate, daysMeetingStrArr);

      
      
      return CalendarHelperFunctions.makeEvent(eventName, location, description, recurrence, LocalDateTime.of(startLocalDate, startLocalTime), 
                                                                           LocalDateTime.of(endLocalDate, endLocalTime));
  }

}